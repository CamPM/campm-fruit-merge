<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Fruit Merge 1.0</title>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>

<style>
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #E6E6FA;
    font-family: 'Segoe UI', sans-serif;
}

canvas {
    display: block;
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
}

.btn-ui {
    position: absolute;
    z-index: 2000;
    border: 2px solid #333;
    font-weight: bold;
    cursor: pointer;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
}

#shop-btn { bottom: 10px; right: 10px; width: 60px; height: 40px; background: #3498db; border-radius: 8px; font-size: 11px; }
#help-btn { bottom: 10px; right: 75px; width: 40px; height: 40px; background: #95a5a6; border-radius: 8px; font-size: 18px; }

.pwr { bottom: 10px; width: 40px; height: 40px; border-radius: 8px; font-size: 18px; }
#p-bomb { left: 10px; background: #e67e22; }
#p-wipe { left: 55px; background: #9b59b6; }
#p-evo  { left: 100px; background: #f1c40f; }

.modal {
    display: none;
    position: absolute;
    inset: 20px;
    background: white;
    z-index: 5000;
    padding: 15px;
    border: 4px solid #3498db;
    border-radius: 20px;
    overflow-y: auto;
}

#game-over {
    display: none;
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.9);
    z-index: 6000;
    color: white;
    text-align: center;
    padding-top: 35vh;
}
</style>
</head>

<body>

<button id="p-bomb" class="btn-ui pwr" onclick="prepPower('bomb')">ðŸ’£</button>
<button id="p-wipe" class="btn-ui pwr" onclick="prepPower('wipe')">ðŸ§¹</button>
<button id="p-evo"  class="btn-ui pwr" onclick="prepPower('evo')">âœ¨</button>

<button id="help-btn" class="btn-ui" onclick="openModal('help-menu')">?</button>
<button id="shop-btn" class="btn-ui" onclick="openModal('shop-menu')">SHOP</button>

<div id="shop-menu" class="modal">
    <h2>Shop</h2>
    <p>Wallet: <b id="bal-ui">0</b></p>
    <button onclick="closeModal('shop-menu')">Close</button>
</div>

<div id="help-menu" class="modal">
    <h3>How To Play</h3>
    <p>Drop items to merge them. Donâ€™t let items stay above the red line.</p>
    <button onclick="closeModal('help-menu')">Start</button>
</div>

<div id="game-over">
    <h1>GAME OVER</h1>
    <p>Score: <span id="final-score">0</span></p>
    <button onclick="restartGame()">Retry</button>
</div>

<script>
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const SKINS = {
    Fruit: ["ðŸ’","ðŸ“","ðŸ‡","ðŸŠ","ðŸŽ","ðŸ","ðŸ‘","ðŸ","ðŸˆ","ðŸ‰","ðŸ¥¥","ðŸŽƒ"]
};

const TIER_COLORS = ["#ff7979","#ffbe76","#f6e58d","#badc58","#7ed6df","#686de0","#4834d4","#f0932b","#eb4d4b","#6ab04c","#130f40","#222f3e"];
const SIZES = [18,25,32,40,50,60,72,85,100,115,135,155];

let state = { score:0, high:0, pts:0, over:false };
let emojiCache = {};
let currentIdx = 0, nextIdx = 1;
let lastX = 200;
let canDrop = true;
let activePower = null;

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ EMOJI CACHE â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function cacheEmojis() {
    emojiCache = {};
    const c = document.createElement('canvas');
    const ctx = c.getContext('2d');
    c.width = c.height = 120;

    SKINS.Fruit.forEach((e,i)=>{
        ctx.clearRect(0,0,120,120);
        ctx.font = "90px serif";
        ctx.textAlign="center";
        ctx.textBaseline="middle";
        ctx.fillText(e,60,60);
        const img = new Image();
        img.src = c.toDataURL();
        emojiCache[i] = img;
    });
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ MATTER â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const { Engine, Render, Runner, Bodies, Composite, Events, Bounds } = Matter;
const engine = Engine.create();

const render = Render.create({
    element: document.body,
    engine,
    options: {
        width: window.innerWidth,
        height: window.innerHeight,
        wireframes: false,
        background: 'transparent'
    }
});

function setupWalls() {
    Composite.clear(engine.world,false);
    const w = render.options.width;
    const h = render.options.height;

    Composite.add(engine.world, [
        Bodies.rectangle(w/2, h-50, w, 20, { isStatic:true }),
        Bodies.rectangle(-10, h/2, 20, h, { isStatic:true }),
        Bodies.rectangle(w+10, h/2, 20, h, { isStatic:true })
    ]);
}

setupWalls();
Render.run(render);
Runner.run(Runner.create(), engine);

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ RENDER LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
Events.on(render, 'afterRender', () => {
    const ctx = render.context;
    const w = render.options.width;
    const h = render.options.height;

    ctx.fillStyle = "rgba(255,255,255,0.96)";
    ctx.fillRect(0,0,w,110);
    ctx.fillRect(0,h-60,w,60);

    ctx.setLineDash([6,6]);
    ctx.strokeStyle = "red";
    ctx.beginPath();
    ctx.moveTo(0,110);
    ctx.lineTo(w,110);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.strokeStyle = "rgba(0,0,0,0.15)";
    ctx.beginPath();
    ctx.moveTo(lastX,110);
    ctx.lineTo(lastX,h-60);
    ctx.stroke();

    if (emojiCache[currentIdx]) {
        ctx.drawImage(emojiCache[currentIdx], lastX-20, 85, 40, 40);
    }

    Composite.allBodies(engine.world).forEach(b=>{
        if(b.plugin?.t!==undefined){
            ctx.save();
            ctx.translate(b.position.x,b.position.y);
            ctx.rotate(b.angle);
            ctx.fillStyle = TIER_COLORS[b.plugin.t];
            ctx.beginPath();
            ctx.arc(0,0,b.circleRadius,0,Math.PI*2);
            ctx.fill();
            if(emojiCache[b.plugin.t]){
                ctx.drawImage(emojiCache[b.plugin.t], -b.circleRadius, -b.circleRadius, b.circleRadius*2, b.circleRadius*2);
            }
            ctx.restore();
        }
    });
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ COLLISIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
Events.on(engine,'collisionStart',e=>{
    e.pairs.forEach(p=>{
        const a=p.bodyA, b=p.bodyB;
        if(a.plugin?.t===b.plugin?.t && a.plugin.t<11){
            const t=a.plugin.t;
            Composite.remove(engine.world,[a,b]);
            Composite.add(engine.world,
                Bodies.circle(
                    (a.position.x+b.position.x)/2,
                    (a.position.y+b.position.y)/2,
                    SIZES[t+1],
                    { restitution:.3, plugin:{t:t+1,s:Date.now()} }
                )
            );
            state.score+=(t+1)*10;
            state.pts+=(t+1);
        }
    });
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ INPUT (CANVAS ONLY) â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const canvas = render.canvas;

canvas.addEventListener('pointermove', e=>{
    lastX = e.clientX;
});

canvas.addEventListener('pointerup', e=>{
    if(state.over || !canDrop) return;
    if(e.clientY < 110 || e.clientY > render.options.height-60) return;

    Composite.add(engine.world,
        Bodies.circle(lastX,110,SIZES[currentIdx],
            { restitution:.3, plugin:{t:currentIdx,s:Date.now()} })
    );

    currentIdx = nextIdx;
    nextIdx = Math.floor(Math.random()*4);
    canDrop=false;
    setTimeout(()=>canDrop=true,500);
});

canvas.addEventListener('touchstart', e=>e.preventDefault(), {passive:false});
canvas.addEventListener('touchmove', e=>e.preventDefault(), {passive:false});
canvas.addEventListener('contextmenu', e=>e.preventDefault());

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function openModal(id){ document.getElementById(id).style.display='block'; }
function closeModal(id){ document.getElementById(id).style.display='none'; }
function prepPower(t){ activePower=t; alert("Power ready"); }
function restartGame(){ location.reload(); }

cacheEmojis();
</script>

</body>
</html>

