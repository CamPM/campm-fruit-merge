<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Fruit Merge v96</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        :root {
            --bg: #fdfbf7; --border-color: #e8e6e1; --text: #5c554a;
            --border-width: 15px;
        }
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background: var(--bg); color: var(--text);
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        /* UI Framework */
        #top-ui { height: 175px; position: absolute; top: 0; width: 100%; border-bottom: var(--border-width) solid var(--border-color); z-index: 100; background: inherit; padding: 15px; box-sizing: border-box; }
        #bottom-ui { height: 100px; position: absolute; bottom: 0; width: 100%; border-top: var(--border-width) solid var(--border-color); display: flex; justify-content: space-around; align-items: center; z-index: 100; background: inherit; }
        #game-container { position: absolute; top: 175px; bottom: 100px; width: 100%; overflow: hidden; background: #fff; border-left: var(--border-width) solid var(--border-color); border-right: var(--border-width) solid var(--border-color); }

        /* Store & Previews */
        .modal { display: none; position: fixed; inset: 0; background: rgba(255,255,255,0.98); z-index: 2000; flex-direction: column; }
        .modal-content { flex: 1; overflow-y: auto; padding: 20px; touch-action: pan-y; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .card { border: 1px solid #eee; border-radius: 12px; padding: 10px; text-align: center; }
        .card.owned { border-color: #88d498; background: #f0faf2; }
        .swatch { width: 100%; height: 30px; border-radius: 6px; margin-bottom: 5px; border: 1px solid rgba(0,0,0,0.05); }

        /* Game Elements */
        .btn { padding: 12px; border-radius: 12px; border: 1px solid var(--border-color); background: #fff; cursor: pointer; }
        .danger-line { position: absolute; top: 195px; width: 100%; border-top: 2px dashed #ff7675; pointer-events: none; z-index: 10; opacity: 0.6; }
        #drop-preview { position: absolute; top: 10px; font-size: 2rem; pointer-events: none; opacity: 0.5; transform: translateX(-50%); }
        #reticle { position: absolute; width: 60px; height: 60px; border: 2px solid #5c554a; border-radius: 50%; display: none; pointer-events: none; transform: translate(-50%, -50%); z-index: 500; }
    </style>
</head>
<body>

<div id="top-ui">
    <div style="display:flex; justify-content: space-between;">
        <div><b>Score:</b> <span id="score">0</span><br><small>High: <span id="best">0</span></small></div>
        <div style="text-align: center;">Next<br><span id="next-preview" style="font-size: 1.5rem;"></span></div>
        <div style="display:flex; gap: 5px;"><button class="btn" onclick="toggleFS()">‚õ∂</button><button class="btn" onclick="openModal('help')">?</button></div>
    </div>
    <div id="progress-icons" style="display:flex; justify-content: space-between; margin-top:15px;"></div>
    <div style="text-align:center; font-weight:bold; margin-top:5px;">Available: $<span id="wallet">0</span></div>
</div>

<div class="danger-line"></div>
<div id="game-container">
    <div id="drop-preview"></div>
    <div id="reticle"></div>
</div>

<div id="bottom-ui">
    <button class="btn power-btn" data-type="bomb">üí£</button>
    <button class="btn power-btn" data-type="broom">üßπ</button>
    <button class="btn power-btn" data-type="wand">ü™Ñ</button>
    <button class="btn" onclick="openModal('store')">üè™ Store</button>
</div>

<div id="help-modal" class="modal"><div class="modal-content"><h2 id="help-title">How to Play</h2><div id="help-text"></div><button class="btn" style="width:100%" onclick="closeModals()">Close</button></div></div>
<div id="store-modal" class="modal"><div class="modal-content"><h2>Store</h2><div style="padding:10px; background:#f9f9f9; border-radius:10px; margin-bottom:15px"><b>Your Wallet:</b> $<span id="store-wallet">0</span></div><div id="store-list"></div><button class="btn" style="width:100%; margin-top:20px" onclick="closeModals()">Back to Game</button></div></div>

<script>
/** * CONSTANTS & DATA
 */
const TIER_COLORS = ['#ffadad','#ffd6a5','#fdffb6','#caffbf','#9bf6ff','#a0c4ff','#bdb2ff','#ffc6ff','#ffdee9','#d4fc79','#96e6a1','#f6d365'];
const DATA = {
    skins: {
        Fruit: ['üçí','üçì','üçá','üçä','üçé','üçê','üçë','üçç','üçà','üçâ','ü••','üéÉ'],
        Plants: ['üå±','üåµ','ü™¥','üå≤','üå≥','üå¥','üéã','üåø','üçÄ','üçÑ','üåª','üåπ'],
        Weather: ['‚òÅÔ∏è','üå§Ô∏è','‚ö°','‚òÄÔ∏è','üå¶Ô∏è','üåßÔ∏è','üå®Ô∏è','‚õàÔ∏è','‚ùÑÔ∏è','üå¨Ô∏è','üåà','üå™Ô∏è'],
        Animals: ['üê≠','üê∞','ü¶ä','üêª','üêº','ü¶Å','üêØ','üê∑','üê∏','üêô','üê≥','ü¶Ñ'],
        Shapes: ['‚ñ≤','‚ñ†','‚¨ì','‚¨¢','‚¨¶','‚¨ó','‚òÖ','‚óÜ','‚úö','‚¨ô','‚¨£','‚¨§'],
        Music: ['üéµ','üé∂','üé∑','üé∏','üéπ','üéª','ü•Å','üìª','üé§','üéß','ü™ï','üìª'],
        Space: ['‚òÑÔ∏è','üõ∞Ô∏è','ü™ê','üåô','‚òÄÔ∏è','üî≠','üöÄ','üëΩ','üõ∏','üåå','üå†','üë©‚ÄçüöÄ'],
        Dessert: ['üç™','üç©','üßÅ','üç¶','üç∞','ü•ß','üç´','üç¨','üç≠','üçÆ','üçØ','üéÇ']
    },
    themes: { Mellow: "#fdfbf7", Midnight: "#1a1a2e", Forest: "#edf5f1", Rose: "#fff5f5", Matcha: "#f2f9f1", Slate: "#f1f3f5" },
    borders: { Steel: "#718096", Gold: "#d4af37", Neon: "#00f2ff", Crimson: "#e53e3e", Mint: "#68d391", Lavender: "#b794f4" },
    outlines: ["None", "White", "Black", "Neon"]
};

let state = {
    score: 0, wallet: parseInt(localStorage.getItem('wallet')) || 1000,
    best: parseInt(localStorage.getItem('highScore')) || 0,
    skin: 'Fruit', owned: JSON.parse(localStorage.getItem('owned')) || ['Fruit', 'Mellow', 'Steel', 'None'],
    unlocked: new Set([0]), next: 0, activePower: null, gameOverTime: null
};

/** * PHYSICS ENGINE
 */
const { Engine, Render, Runner, Bodies, Composite, Events, Vector, Query } = Matter;
const container = document.getElementById('game-container');
const engine = Engine.create({ gravity: { y: 1.5 }, enableSleeping: false });
const render = Render.create({
    element: container, engine: engine,
    options: { width: window.innerWidth, height: container.clientHeight, wireframes: false, background: 'transparent' }
});

// Create Persistent Boundaries
function initBoundaries() {
    Composite.clear(engine.world);
    const floor = Bodies.rectangle(window.innerWidth/2, container.clientHeight + 10, window.innerWidth, 25, { isStatic: true, label: 'ground' });
    const lW = Bodies.rectangle(-10, container.clientHeight/2, 20, container.clientHeight, { isStatic: true });
    const rW = Bodies.rectangle(window.innerWidth + 10, container.clientHeight/2, 20, container.clientHeight, { isStatic: true });
    Composite.add(engine.world, [floor, lW, rW]);
}

function spawn(x, y, tier) {
    const r = 15 + (tier * 7.5);
    const b = Bodies.circle(x, y, r, { restitution: 0.3, friction: 0.1, plugin: { tier } });
    Composite.add(engine.world, b);
}

/** * INTERACTION & TARGETING
 */
const reticle = document.getElementById('reticle');
const preview = document.getElementById('drop-preview');

document.querySelectorAll('.power-btn').forEach(btn => {
    btn.addEventListener('touchstart', (e) => {
        state.activePower = btn.dataset.type;
        reticle.style.display = 'block';
    });
});

window.addEventListener('touchmove', (e) => {
    const touch = e.touches[0];
    const rect = container.getBoundingClientRect();
    const x = touch.clientX;
    const y = touch.clientY - rect.top;

    if (state.activePower) {
        reticle.style.left = x + 'px';
        reticle.style.top = y + rect.top + 'px';
    } else {
        preview.style.left = x + 'px';
        preview.innerText = DATA.skins[state.skin][state.next];
    }
});

window.addEventListener('touchend', (e) => {
    const touch = e.changedTouches[0];
    const rect = container.getBoundingClientRect();
    const x = touch.clientX;
    const y = touch.clientY - rect.top;

    if (state.activePower) {
        const body = Query.point(Composite.allBodies(engine.world), { x, y })[0];
        handlePower(state.activePower, body, x, y);
        state.activePower = null;
        reticle.style.display = 'none';
    } else if (touch.clientY > 175 && touch.clientY < window.innerHeight - 100) {
        spawn(x, 40, state.next);
        state.next = Math.floor(Math.random() * 4);
        updateUI();
    }
});

function handlePower(type, target, x, y) {
    const all = Composite.allBodies(engine.world);
    if (type === 'bomb') {
        const affected = all.filter(b => Vector.magnitude(Vector.sub(b.position, {x, y})) < 80);
        Composite.remove(engine.world, affected);
    } else if (target && target.plugin.tier !== undefined) {
        if (type === 'broom') {
            const same = all.filter(b => b.plugin.tier === target.plugin.tier);
            Composite.remove(engine.world, same);
        } else if (type === 'wand' && target.plugin.tier < 11) {
            const tier = target.plugin.tier + 1;
            const pos = {...target.position};
            Composite.remove(engine.world, target);
            spawn(pos.x, pos.y, tier);
        }
    }
}

/** * RENDERING & HITBOXES
 */
Events.on(render, 'afterRender', () => {
    const ctx = render.context;
    let violation = false;
    const bodies = Composite.allBodies(engine.world);

    bodies.forEach(body => {
        if (body.plugin.tier !== undefined) {
            const tier = body.plugin.tier;
            const r = 15 + (tier * 7.5);
            
            ctx.save();
            ctx.translate(body.position.x, body.position.y);
            ctx.rotate(body.angle);
            
            // Tier-Consistent Hitbox Color
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.fillStyle = TIER_COLORS[tier];
            ctx.globalAlpha = 0.3;
            ctx.fill();
            ctx.globalAlpha = 1.0;

            ctx.font = `${r * 1.6}px Arial`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(DATA.skins[state.skin][tier], 0, 0);
            ctx.restore();

            if (body.position.y < 20) violation = true;
        }
    });

    if (violation) {
        if (!state.gameOverTime) state.gameOverTime = Date.now();
        else if (Date.now() - state.gameOverTime > 2000) {
            initBoundaries(); // Clean wipe but keep boundaries
            state.score = 0; state.gameOverTime = null;
            updateUI();
        }
    } else state.gameOverTime = null;
});

// Collision Merge
Events.on(engine, 'collisionStart', (e) => {
    e.pairs.forEach(pair => {
        const { bodyA, bodyB } = pair;
        if (bodyA.plugin?.tier === bodyB.plugin?.tier && bodyA.plugin.tier < 11) {
            const pos = Vector.div(Vector.add(bodyA.position, bodyB.position), 2);
            const tier = bodyA.plugin.tier + 1;
            Composite.remove(engine.world, [bodyA, bodyB]);
            spawn(pos.x, pos.y, tier);
            state.score += (tier * 10); state.wallet += tier;
            state.unlocked.add(tier);
            updateUI();
        }
    });
});

/** * STORE & UI
 */
function updateUI() {
    document.getElementById('score').innerText = state.score;
    document.getElementById('wallet').innerText = state.wallet;
    document.getElementById('store-wallet').innerText = state.wallet;
    document.getElementById('best').innerText = state.best;
    document.getElementById('next-preview').innerText = DATA.skins[state.skin][state.next];
    
    const p = document.getElementById('progress-icons');
    p.innerHTML = '';
    DATA.skins[state.skin].forEach((s, i) => {
        const div = document.createElement('div');
        div.style.opacity = state.unlocked.has(i) ? '1' : '0.15';
        div.innerText = s;
        p.appendChild(div);
    });
    localStorage.setItem('wallet', state.wallet);
    localStorage.setItem('owned', JSON.stringify(state.owned));
}

function renderStore() {
    const list = document.getElementById('store-list');
    list.innerHTML = '';
    
    const cats = [
        { n: 'Skins', d: DATA.skins, p: 500 },
        { n: 'Themes', d: DATA.themes, p: 300 },
        { n: 'Borders', d: DATA.borders, p: 200 }
    ];

    cats.forEach(cat => {
        list.innerHTML += `<h3>${cat.n}</h3>`;
        const g = document.createElement('div'); g.className = 'grid';
        Object.keys(cat.d).forEach(k => {
            const isOwned = state.owned.includes(k);
            const card = document.createElement('div');
            card.className = `card ${isOwned ? 'owned' : ''}`;
            
            // Preview Logic
            let previewHTML = '';
            if (cat.n === 'Skins') previewHTML = `<div style="font-size:1.5rem">${cat.d[k][0]}</div>`;
            else previewHTML = `<div class="swatch" style="background:${cat.d[k]}"></div>`;

            card.innerHTML = `${previewHTML}<b>${k}</b><br>${isOwned ? 'Equipped' : '$'+cat.p}`;
            card.onclick = () => {
                if (!isOwned && state.wallet >= cat.p) {
                    state.wallet -= cat.p; state.owned.push(k);
                    updateUI(); renderStore();
                } else if (isOwned) {
                    if (cat.n === 'Skins') state.skin = k;
                    if (cat.n === 'Themes') document.documentElement.style.setProperty('--bg', cat.d[k]);
                    if (cat.n === 'Borders') document.documentElement.style.setProperty('--border-color', cat.d[k]);
                    updateUI();
                }
            };
            g.appendChild(card);
        });
        list.appendChild(g);
    });
}

function openModal(id) { if(id === 'store') renderStore(); document.getElementById(id+'-modal').style.display = 'flex'; }
function closeModals() { document.querySelectorAll('.modal').forEach(m => m.style.display = 'none'); }
function toggleFS() { document.fullscreenElement ? document.exitFullscreen() : document.documentElement.requestFullscreen(); }

initBoundaries();
updateUI();
Render.run(render);
Runner.run(Runner.create(), engine);
</script>
</body>
</html>
